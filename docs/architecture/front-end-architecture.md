# Frontend Architecture: Universal React Native

## Overview

Sanskrit Student uses a **Universal React Native** architecture that enables a single codebase to run on web browsers, iOS, and Android platforms. This approach prioritizes code reuse and consistent user experience across all platforms.

## Architecture Stack

### Core Technologies

```
├── Runtime & UI Layer
│   ├── React Native          - Cross-platform UI primitives (View, Text, etc.)
│   ├── React Native Web      - Renders React Native components in browsers
│   └── Expo SDK             - Tooling, bundling, and native device APIs
│
├── Navigation
│   └── Expo Router          - File-based routing for all platforms
│
├── Data Layer
│   ├── Apollo Client        - GraphQL client with caching
│   └── GraphQL Code Generator - Auto-generated TypeScript types and hooks
│
├── Styling
│   ├── NativeWind (primary)  - Tailwind CSS for React Native
│   └── StyleSheet (fallback) - React Native's built-in styling
│
└── Language
    └── TypeScript           - End-to-end type safety
```

## Project Structure

```
sanskrit-student/
├── backend/                    # GraphQL server (existing)
│   ├── src/
│   │   ├── domain/            # Business logic
│   │   ├── adapters/          # External integrations
│   │   └── server.ts          # GraphQL Yoga server
│   └── package.json
│
├── app/                        # Universal React Native frontend
│   ├── app/                    # Expo Router (file-based routing)
│   │   ├── index.tsx          # Home/landing screen
│   │   ├── translate.tsx      # Text translation screen
│   │   ├── camera.tsx         # OCR image capture screen
│   │   ├── history.tsx        # Translation history
│   │   └── _layout.tsx        # Root layout (navigation structure)
│   │
│   ├── components/             # Reusable UI components
│   │   ├── ui/                # Generic UI components
│   │   │   ├── Button.tsx
│   │   │   ├── Card.tsx
│   │   │   └── Input.tsx
│   │   ├── sanskrit/          # Sanskrit-specific components
│   │   │   ├── DevanagariText.tsx
│   │   │   ├── IastText.tsx
│   │   │   └── ScriptSelector.tsx
│   │   ├── translation/       # Translation feature components
│   │   │   ├── SutraInput.tsx
│   │   │   ├── TranslationResult.tsx
│   │   │   ├── WordBreakdown.tsx
│   │   │   └── AlternativeTranslations.tsx
│   │   └── ocr/               # OCR feature components
│   │       ├── ImageCapture.tsx
│   │       ├── ImagePreview.tsx
│   │       └── OcrConfidence.tsx
│   │
│   ├── graphql/                # GraphQL operations
│   │   ├── queries/
│   │   │   └── translateSutra.ts
│   │   ├── mutations/
│   │   │   └── translateSutraFromImage.ts
│   │   └── generated/          # Auto-generated by codegen
│   │       ├── graphql.ts      # TypeScript types
│   │       └── hooks.ts        # Typed Apollo hooks
│   │
│   ├── lib/                    # Configuration and utilities
│   │   ├── apollo.ts          # Apollo Client setup
│   │   ├── fonts.ts           # Custom font loading (Devanagari)
│   │   └── storage.ts         # Async storage wrapper
│   │
│   ├── hooks/                  # Custom React hooks
│   │   ├── useTranslation.ts
│   │   └── useCamera.ts
│   │
│   ├── package.json
│   ├── app.json                # Expo configuration
│   ├── metro.config.js         # Metro bundler config
│   ├── tailwind.config.js      # NativeWind/Tailwind config
│   └── tsconfig.json           # TypeScript config
│
└── shared/                     # Shared code (optional)
    └── types/                  # Shared TypeScript types
```

## Key Design Decisions

### 1. React Native as Foundation

**Why React Native over web-first (Next.js)?**

- Mobile-first use case: Sanskrit students benefit from camera-based OCR on mobile devices
- True cross-platform code reuse (not just responsive web)
- Native performance characteristics for complex text rendering (Devanagari script)
- Access to device APIs (camera, file system, offline storage)

### 2. Expo for Tooling

**Why Expo over bare React Native?**

- Simplified build process for iOS/Android
- Built-in web support via React Native Web
- Managed workflow reduces native code complexity
- Excellent developer experience with hot reload
- EAS Build for cloud-based native builds

### 3. Expo Router for Navigation

**Why Expo Router over React Navigation?**

- File-based routing (familiar to web developers)
- Single routing model for web and native
- Automatic deep linking support
- Type-safe navigation with TypeScript
- Seamless web URL routing

### 4. Apollo Client for GraphQL

**Why Apollo over urql or other clients?**

- Industry standard with extensive documentation
- First-class React Native support
- Robust caching and state management
- File upload support (for OCR image mutation)
- GraphQL Code Generator integration for type safety

### 5. NativeWind for Styling

**Why NativeWind over plain StyleSheet?**

- Tailwind CSS utility classes (developer productivity)
- Consistent styling API across web and native
- Responsive design utilities
- Theme support for light/dark modes
- Reduces custom CSS code

## Platform-Specific Considerations

### Web (Browser)

- React Native Web translates RN components to HTML/CSS
- Expo Router provides standard web routing (URLs work as expected)
- File uploads use standard HTML `<input type="file">`
- localStorage for persistence

### iOS

- Native builds via EAS Build or Xcode
- Camera access via `expo-camera`
- Native file picker via `expo-image-picker`
- AsyncStorage for persistence
- App Store distribution

### Android

- Native builds via EAS Build or Android Studio
- Camera access via `expo-camera`
- Native file picker via `expo-image-picker`
- AsyncStorage for persistence
- Google Play Store distribution

## Data Flow

### GraphQL Integration

```typescript
// 1. Define GraphQL operation
const TRANSLATE_SUTRA = gql`
  query TranslateSutra($sutra: String!) {
    translateSutra(sutra: $sutra) {
      originalText
      iastText
      words {
        word
        meanings
      }
      alternativeTranslations
    }
  }
`;

// 2. GraphQL Code Generator creates typed hook
// graphql/generated/hooks.ts (auto-generated)
export function useTranslateSutraQuery(
  baseOptions: ApolloReactHooks.QueryHookOptions<
    TranslateSutraQuery,
    TranslateSutraQueryVariables
  >
) { ... }

// 3. Use in component with full type safety
function TranslateScreen() {
  const { data, loading, error } = useTranslateSutraQuery({
    variables: { sutra: userInput },
  });

  // TypeScript knows exact shape of data
  return <TranslationResult translation={data?.translateSutra} />;
}
```

### File Upload (OCR Images)

```typescript
// Uses Apollo Client's file upload capability
const TRANSLATE_FROM_IMAGE = gql`
  mutation TranslateSutraFromImage($image: Upload!) {
    translateSutraFromImage(image: $image) {
      extractedText
      ocrConfidence
      iastText
      words { word meanings }
    }
  }
`;

// On mobile: capture from camera
const image = await ImagePicker.launchCameraAsync();

// On web: file input
const file = input.files[0];

// Both use same mutation
const { data } = await translateFromImage({
  variables: { image: file }
});
```

## Development Workflow

### Local Development

```bash
# Install dependencies
npm install

# Start Expo development server
npx expo start

# Options:
# - Press 'w' to open in web browser
# - Press 'i' to open in iOS simulator (Mac only)
# - Press 'a' to open in Android emulator
# - Scan QR code with Expo Go app for physical device testing
```

### Type Generation

```bash
# Generate TypeScript types from GraphQL schema
npm run codegen

# This creates:
# - graphql/generated/graphql.ts (types)
# - graphql/generated/hooks.ts (typed Apollo hooks)
```

### Platform-Specific Builds

```bash
# Web build (static export)
npx expo export:web
# Output: web-build/ directory (deploy to Vercel/Netlify)

# iOS build (requires Apple Developer account)
npx eas build --platform ios

# Android build
npx eas build --platform android
```

## Features Enabled by This Architecture

### 1. Sanskrit Text Rendering

- Custom Devanagari fonts via `expo-font`
- Unicode text support across all platforms
- IAST (romanized Sanskrit) rendering
- Script conversion UI (Devanagari ↔ IAST)

### 2. OCR Image Capture

- **Mobile**: Native camera access via `expo-camera`
- **Web**: File upload fallback
- Image preprocessing before GraphQL upload
- Confidence indicators for OCR results

### 3. Offline Support

- Apollo Client cache (in-memory)
- AsyncStorage/localStorage for persistence
- Queue mutations when offline (Apollo Link)
- Translation history storage

### 4. Responsive Design

- NativeWind responsive utilities
- Platform-specific layouts via `Platform.select()`
- Adaptive UI for tablets vs phones
- Desktop-optimized web layout

## Performance Considerations

### Code Splitting

- Expo Router automatically code-splits by route
- Lazy load heavy components (camera, image processing)
- Minimize initial bundle size

### Caching Strategy

```typescript
// Apollo Client cache configuration
const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        translateSutra: {
          // Cache translations by sutra text
          keyArgs: ['sutra'],
        },
      },
    },
  },
});
```

### Image Optimization

- Compress images before upload (reduce GraphQL payload)
- Use `expo-image` for optimized image rendering
- Progressive loading for large images

## Security Considerations

### API Key Management

```typescript
// Never commit API keys to repository
// Use environment variables via Expo's config

// app.json
{
  "expo": {
    "extra": {
      "graphqlEndpoint": process.env.GRAPHQL_ENDPOINT
    }
  }
}

// Access in app
import Constants from 'expo-constants';
const endpoint = Constants.expoConfig?.extra?.graphqlEndpoint;
```

### File Upload Validation

- Client-side: Check file type and size before upload
- Server-side: Validate file type in GraphQL resolver
- Limit upload size to prevent abuse

## Testing Strategy

### Unit Tests

- Jest for component logic
- React Native Testing Library for component rendering
- Mock Apollo Client for GraphQL operations

### E2E Tests

- Detox for native iOS/Android testing
- Playwright for web testing
- Test critical flows (translation, OCR)

## Deployment

### Web

```bash
# Build static site
npx expo export:web

# Deploy to Vercel
vercel --prod

# Or Netlify
netlify deploy --prod --dir=web-build
```

### Mobile

```bash
# Configure EAS
npx eas build:configure

# Build and submit to App Store
npx eas build --platform ios --auto-submit

# Build and submit to Play Store
npx eas build --platform android --auto-submit
```

## Future Enhancements

### Progressive Web App (PWA)

- Add service worker for offline web support
- Make web version installable
- Push notifications for study reminders

### Native Features

- Handwriting recognition for Sanskrit characters
- Audio playback for Sanskrit pronunciation
- Haptic feedback for interactive learning

### Performance

- Implement virtual scrolling for long translation lists
- Add skeleton screens for loading states
- Optimize font loading (subset Devanagari glyphs)

## References

- [Expo Documentation](https://docs.expo.dev/)
- [React Native Web](https://necolas.github.io/react-native-web/)
- [Expo Router](https://docs.expo.dev/router/introduction/)
- [Apollo Client](https://www.apollographql.com/docs/react/)
- [NativeWind](https://www.nativewind.dev/)
- [GraphQL Code Generator](https://the-guild.dev/graphql/codegen)

## Related ADRs

- [ADR-0002: Universal React Native Frontend](../adr/0002-universal-react-native-frontend.md)

---

**Last Updated:** 2026-01-31
**Status:** Accepted
